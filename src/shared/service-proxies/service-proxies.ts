/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.1.5.0 (NJsonSchema v10.0.27.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AdComplaintServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editAdComplaint(body: EditAdComplaintCommand | undefined): Observable<AdComplaintDto> {
        let url_ = this.baseUrl + "/api/AdComplaint/edit-AdComplaint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditAdComplaint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditAdComplaint(<any>response_);
                } catch (e) {
                    return <Observable<AdComplaintDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdComplaintDto>><any>_observableThrow(response_);
        }));
    }

    protected processEditAdComplaint(response: HttpResponseBase): Observable<AdComplaintDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdComplaintDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdComplaintDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addAdComplaint(body: CreateAdComplaintCommand | undefined): Observable<AdComplaintDto> {
        let url_ = this.baseUrl + "/api/AdComplaint/add-AdComplaint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAdComplaint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAdComplaint(<any>response_);
                } catch (e) {
                    return <Observable<AdComplaintDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdComplaintDto>><any>_observableThrow(response_);
        }));
    }

    protected processAddAdComplaint(response: HttpResponseBase): Observable<AdComplaintDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdComplaintDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdComplaintDto>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getAllAdComplaint(page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortOrder: string | undefined, filter: string | undefined): Observable<AdComplaintDtoPageList> {
        let url_ = this.baseUrl + "/api/AdComplaint/get-all-AdComplaint?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAdComplaint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAdComplaint(<any>response_);
                } catch (e) {
                    return <Observable<AdComplaintDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdComplaintDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAdComplaint(response: HttpResponseBase): Observable<AdComplaintDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdComplaintDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdComplaintDtoPageList>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAdComplaintDetail(id: string | undefined): Observable<AdComplaintDto> {
        let url_ = this.baseUrl + "/api/AdComplaint/get-AdComplaint-detail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdComplaintDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdComplaintDetail(<any>response_);
                } catch (e) {
                    return <Observable<AdComplaintDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdComplaintDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdComplaintDetail(response: HttpResponseBase): Observable<AdComplaintDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdComplaintDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdComplaintDto>(<any>null);
    }
}

@Injectable()
export class AdvertisementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    applyForAdvertisement(body: ApplyForAdvertisementCommand | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Advertisement/apply-for-advertisement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApplyForAdvertisement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApplyForAdvertisement(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApplyForAdvertisement(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addAdvertisementWithoutSpace(body: CreateAdvertisementWithoutSPaceCommand | undefined): Observable<AdvertisementDto> {
        let url_ = this.baseUrl + "/api/Advertisement/add-advertisement-without-space";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAdvertisementWithoutSpace(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAdvertisementWithoutSpace(<any>response_);
                } catch (e) {
                    return <Observable<AdvertisementDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdvertisementDto>><any>_observableThrow(response_);
        }));
    }

    protected processAddAdvertisementWithoutSpace(response: HttpResponseBase): Observable<AdvertisementDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvertisementDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdvertisementDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createReservationByClient(body: CreateReservationByClientCommand | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Advertisement/create-reservation-by-client";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateReservationByClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateReservationByClient(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCreateReservationByClient(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    stopAd(body: StopAdvertisementCommand | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Advertisement/stop-ad";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStopAd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStopAd(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processStopAd(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCommercialRecord(body: AddCommercialRecordCommand | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Advertisement/add-commercial-record";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCommercialRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCommercialRecord(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAddCommercialRecord(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addPaidService(body: AddPaidServicesCommand | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Advertisement/add-paid-service";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPaidService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPaidService(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAddPaidService(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editPaidService(body: EditPaidServicesCommand | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Advertisement/edit-paid-service";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditPaidService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditPaidService(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processEditPaidService(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getMyService(body: GetMyServiceCommand | undefined): Observable<GetPaidServicesDto[]> {
        let url_ = this.baseUrl + "/api/Advertisement/get-my-service";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyService(<any>response_);
                } catch (e) {
                    return <Observable<GetPaidServicesDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPaidServicesDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyService(response: HttpResponseBase): Observable<GetPaidServicesDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetPaidServicesDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPaidServicesDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAdServices(body: GetAdServicesCommand | undefined): Observable<PaidServicesOfAdDto[]> {
        let url_ = this.baseUrl + "/api/Advertisement/get-ad-services";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdServices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdServices(<any>response_);
                } catch (e) {
                    return <Observable<PaidServicesOfAdDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaidServicesOfAdDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdServices(response: HttpResponseBase): Observable<PaidServicesOfAdDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaidServicesOfAdDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaidServicesOfAdDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editAdvertisement(body: EditAdvertisementCommand | undefined): Observable<AdvertisementDto> {
        let url_ = this.baseUrl + "/api/Advertisement/edit-Advertisement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditAdvertisement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditAdvertisement(<any>response_);
                } catch (e) {
                    return <Observable<AdvertisementDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdvertisementDto>><any>_observableThrow(response_);
        }));
    }

    protected processEditAdvertisement(response: HttpResponseBase): Observable<AdvertisementDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvertisementDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdvertisementDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addAdvertisement(body: CreateAdvertisementCommand | undefined): Observable<AdvertisementDto> {
        let url_ = this.baseUrl + "/api/Advertisement/add-advertisement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAdvertisement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAdvertisement(<any>response_);
                } catch (e) {
                    return <Observable<AdvertisementDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdvertisementDto>><any>_observableThrow(response_);
        }));
    }

    protected processAddAdvertisement(response: HttpResponseBase): Observable<AdvertisementDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvertisementDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdvertisementDto>(<any>null);
    }

    /**
     * @param enable (optional) 
     * @param body (optional) 
     * @return Success
     */
    disableAdvertisement(enable: boolean | undefined, body: string | undefined): Observable<AdvertisementDto> {
        let url_ = this.baseUrl + "/api/Advertisement/disable-Advertisement?";
        if (enable === null)
            throw new Error("The parameter 'enable' cannot be null.");
        else if (enable !== undefined)
            url_ += "enable=" + encodeURIComponent("" + enable) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableAdvertisement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableAdvertisement(<any>response_);
                } catch (e) {
                    return <Observable<AdvertisementDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdvertisementDto>><any>_observableThrow(response_);
        }));
    }

    protected processDisableAdvertisement(response: HttpResponseBase): Observable<AdvertisementDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvertisementDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdvertisementDto>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getAllAdvertisement(page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortOrder: string | undefined, filter: string | undefined): Observable<AdvertisementDtoPageList> {
        let url_ = this.baseUrl + "/api/Advertisement/get-all-advertisement?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAdvertisement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAdvertisement(<any>response_);
                } catch (e) {
                    return <Observable<AdvertisementDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdvertisementDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAdvertisement(response: HttpResponseBase): Observable<AdvertisementDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvertisementDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdvertisementDtoPageList>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getAllAdvertisementDashboard(page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortOrder: string | undefined, filter: string | undefined): Observable<AdvertisementDtoPageList> {
        let url_ = this.baseUrl + "/api/Advertisement/get-all-advertisement-dashboard?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAdvertisementDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAdvertisementDashboard(<any>response_);
                } catch (e) {
                    return <Observable<AdvertisementDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdvertisementDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAdvertisementDashboard(response: HttpResponseBase): Observable<AdvertisementDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvertisementDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdvertisementDtoPageList>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchAdvertisement(body: SearchAdvertisementCommand | undefined): Observable<AdvertisementDtoPageList> {
        let url_ = this.baseUrl + "/api/Advertisement/Search-Advertisement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchAdvertisement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchAdvertisement(<any>response_);
                } catch (e) {
                    return <Observable<AdvertisementDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdvertisementDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processSearchAdvertisement(response: HttpResponseBase): Observable<AdvertisementDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvertisementDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdvertisementDtoPageList>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAdvertisementDetail(id: string | undefined): Observable<SpaceInfoDto> {
        let url_ = this.baseUrl + "/api/Advertisement/get-advertisement-detail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdvertisementDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdvertisementDetail(<any>response_);
                } catch (e) {
                    return <Observable<SpaceInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SpaceInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdvertisementDetail(response: HttpResponseBase): Observable<SpaceInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SpaceInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpaceInfoDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAdvertisementById(id: string | undefined): Observable<AdsDto> {
        let url_ = this.baseUrl + "/api/Advertisement/get-advertisement-ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdvertisementById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdvertisementById(<any>response_);
                } catch (e) {
                    return <Observable<AdsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdvertisementById(response: HttpResponseBase): Observable<AdsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdsDto>(<any>null);
    }

    /**
     * @param lat (optional) 
     * @param lng (optional) 
     * @return Success
     */
    getTopAds(lat: number | undefined, lng: number | undefined): Observable<AdsDto[]> {
        let url_ = this.baseUrl + "/api/Advertisement/get-top-ads?";
        if (lat === null)
            throw new Error("The parameter 'lat' cannot be null.");
        else if (lat !== undefined)
            url_ += "Lat=" + encodeURIComponent("" + lat) + "&"; 
        if (lng === null)
            throw new Error("The parameter 'lng' cannot be null.");
        else if (lng !== undefined)
            url_ += "Lng=" + encodeURIComponent("" + lng) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopAds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopAds(<any>response_);
                } catch (e) {
                    return <Observable<AdsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTopAds(response: HttpResponseBase): Observable<AdsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdsDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getMyAds(body: GetMyAds | undefined): Observable<AdsDto[]> {
        let url_ = this.baseUrl + "/api/Advertisement/get-my-ads";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyAds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyAds(<any>response_);
                } catch (e) {
                    return <Observable<AdsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyAds(response: HttpResponseBase): Observable<AdsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdsDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addFavourite(body: AddFavouriteCommand | undefined): Observable<AddFavouriteDto> {
        let url_ = this.baseUrl + "/api/Advertisement/add-Favourite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddFavourite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddFavourite(<any>response_);
                } catch (e) {
                    return <Observable<AddFavouriteDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddFavouriteDto>><any>_observableThrow(response_);
        }));
    }

    protected processAddFavourite(response: HttpResponseBase): Observable<AddFavouriteDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddFavouriteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddFavouriteDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getMyFavourites(body: GetMyFavourite | undefined): Observable<AdsDto[]> {
        let url_ = this.baseUrl + "/api/Advertisement/get-my-favourites";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyFavourites(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyFavourites(<any>response_);
                } catch (e) {
                    return <Observable<AdsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyFavourites(response: HttpResponseBase): Observable<AdsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdsDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAdIntervalsInstallment(body: GetAdIntervalInstallments | undefined): Observable<AdIntervalInstallmentDto[]> {
        let url_ = this.baseUrl + "/api/Advertisement/get-ad-intervalsInstallment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdIntervalsInstallment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdIntervalsInstallment(<any>response_);
                } catch (e) {
                    return <Observable<AdIntervalInstallmentDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdIntervalInstallmentDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdIntervalsInstallment(response: HttpResponseBase): Observable<AdIntervalInstallmentDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdIntervalInstallmentDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdIntervalInstallmentDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getMySpaces(body: GetMySpaces | undefined): Observable<AdsDto[]> {
        let url_ = this.baseUrl + "/api/Advertisement/get-my-Spaces";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMySpaces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMySpaces(<any>response_);
                } catch (e) {
                    return <Observable<AdsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMySpaces(response: HttpResponseBase): Observable<AdsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdsDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAdIntervals(body: GetAdIntervals | undefined): Observable<AdIntervalsDto[]> {
        let url_ = this.baseUrl + "/api/Advertisement/get-ad-intervals";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdIntervals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdIntervals(<any>response_);
                } catch (e) {
                    return <Observable<AdIntervalsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdIntervalsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdIntervals(response: HttpResponseBase): Observable<AdIntervalsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdIntervalsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdIntervalsDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getMyServices(body: GetMyServices | undefined): Observable<ServicesDto[]> {
        let url_ = this.baseUrl + "/api/Advertisement/get-my-services";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyServices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyServices(<any>response_);
                } catch (e) {
                    return <Observable<ServicesDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServicesDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyServices(response: HttpResponseBase): Observable<ServicesDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServicesDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServicesDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addRating(body: AddRatingCommand | undefined): Observable<RatingDto> {
        let url_ = this.baseUrl + "/api/Advertisement/add-rating";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRating(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRating(<any>response_);
                } catch (e) {
                    return <Observable<RatingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RatingDto>><any>_observableThrow(response_);
        }));
    }

    protected processAddRating(response: HttpResponseBase): Observable<RatingDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RatingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RatingDto>(<any>null);
    }
}

@Injectable()
export class AuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginCommand | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<Result>><any>_observableThrow(e);
                }
            } else
                return <Observable<Result>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordCommand | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/Auth/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<Result>><any>_observableThrow(e);
                }
            } else
                return <Observable<Result>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    forgetPassword(body: ForgetPasswordCommand | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/Auth/forget-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgetPassword(<any>response_);
                } catch (e) {
                    return <Observable<Result>><any>_observableThrow(e);
                }
            } else
                return <Observable<Result>><any>_observableThrow(response_);
        }));
    }

    protected processForgetPassword(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifyCode(body: VerifyCodeCommand | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/Auth/verify-code";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyCode(<any>response_);
                } catch (e) {
                    return <Observable<Result>><any>_observableThrow(e);
                }
            } else
                return <Observable<Result>><any>_observableThrow(response_);
        }));
    }

    protected processVerifyCode(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordCommand | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/Auth/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<Result>><any>_observableThrow(e);
                }
            } else
                return <Observable<Result>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientRegister(body: ClientRegisterCommand | undefined): Observable<ClientDto> {
        let url_ = this.baseUrl + "/api/Auth/client-register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientRegister(<any>response_);
                } catch (e) {
                    return <Observable<ClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processClientRegister(response: HttpResponseBase): Observable<ClientDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    serviceProviderRegister(body: ServiceProviderRegisterCommand | undefined): Observable<ClientDto> {
        let url_ = this.baseUrl + "/api/Auth/service-provider-register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processServiceProviderRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processServiceProviderRegister(<any>response_);
                } catch (e) {
                    return <Observable<ClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processServiceProviderRegister(response: HttpResponseBase): Observable<ClientDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUserById(body: GetUserByIdCommand | undefined): Observable<ClientDto> {
        let url_ = this.baseUrl + "/api/Auth/Get-User-By-Id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserById(<any>response_);
                } catch (e) {
                    return <Observable<ClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserById(response: HttpResponseBase): Observable<ClientDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isUserHasCommercialRecord(body: IsUserHasCommercialRecordCommand | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Auth/is-user-has-commercial-record";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUserHasCommercialRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUserHasCommercialRecord(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsUserHasCommercialRecord(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class ContactUsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param filter (optional) 
     * @return Success
     */
    contactUs(page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortOrder: string | undefined, filter: string | undefined): Observable<ContactUsDtoPageList> {
        let url_ = this.baseUrl + "/api/ContactUs/ContactUs?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContactUs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContactUs(<any>response_);
                } catch (e) {
                    return <Observable<ContactUsDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactUsDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processContactUs(response: HttpResponseBase): Observable<ContactUsDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactUsDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactUsDtoPageList>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addContactUs(body: AddContactUsCommand | undefined): Observable<ContactUsDtoPageListPageList> {
        let url_ = this.baseUrl + "/api/ContactUs/ContactUs/add-ContactUs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddContactUs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddContactUs(<any>response_);
                } catch (e) {
                    return <Observable<ContactUsDtoPageListPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactUsDtoPageListPageList>><any>_observableThrow(response_);
        }));
    }

    protected processAddContactUs(response: HttpResponseBase): Observable<ContactUsDtoPageListPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactUsDtoPageListPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactUsDtoPageListPageList>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editContactUs(id: string, body: EditContactUsCommand | undefined): Observable<ContactUsDtoPageList> {
        let url_ = this.baseUrl + "/api/ContactUs/ContactUs/edit-ContactUs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditContactUs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditContactUs(<any>response_);
                } catch (e) {
                    return <Observable<ContactUsDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactUsDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processEditContactUs(response: HttpResponseBase): Observable<ContactUsDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactUsDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactUsDtoPageList>(<any>null);
    }

    /**
     * @return Success
     */
    deleteContactUs(id: string): Observable<ContactUsDtoPageList> {
        let url_ = this.baseUrl + "/api/ContactUs/ContactUs/delete-ContactUs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContactUs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContactUs(<any>response_);
                } catch (e) {
                    return <Observable<ContactUsDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactUsDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteContactUs(response: HttpResponseBase): Observable<ContactUsDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactUsDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactUsDtoPageList>(<any>null);
    }
}

@Injectable()
export class GeneralConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editGeneralConfiguration(body: EditGeneralConfigurationCommand | undefined): Observable<GeneralConfigurationDto> {
        let url_ = this.baseUrl + "/api/GeneralConfiguration/edit-GeneralConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditGeneralConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditGeneralConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<GeneralConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GeneralConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processEditGeneralConfiguration(response: HttpResponseBase): Observable<GeneralConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GeneralConfigurationDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addGeneralConfiguration(body: CreateGeneralConfigurationCommand | undefined): Observable<GeneralConfigurationDto> {
        let url_ = this.baseUrl + "/api/GeneralConfiguration/add-GeneralConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddGeneralConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddGeneralConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<GeneralConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GeneralConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processAddGeneralConfiguration(response: HttpResponseBase): Observable<GeneralConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GeneralConfigurationDto>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getAllGeneralConfiguration(page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortOrder: string | undefined, filter: string | undefined): Observable<GeneralConfigurationDtoPageList> {
        let url_ = this.baseUrl + "/api/GeneralConfiguration/get-all-GeneralConfiguration?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGeneralConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGeneralConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<GeneralConfigurationDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<GeneralConfigurationDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllGeneralConfiguration(response: HttpResponseBase): Observable<GeneralConfigurationDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralConfigurationDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GeneralConfigurationDtoPageList>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getGeneralConfigurationDetail(id: number | undefined): Observable<GeneralConfigurationDto> {
        let url_ = this.baseUrl + "/api/GeneralConfiguration/get-GeneralConfiguration-detail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralConfigurationDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralConfigurationDetail(<any>response_);
                } catch (e) {
                    return <Observable<GeneralConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GeneralConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGeneralConfigurationDetail(response: HttpResponseBase): Observable<GeneralConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GeneralConfigurationDto>(<any>null);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getAllNotification(page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortOrder: string | undefined, filter: string | undefined): Observable<NotificationDtoPageList> {
        let url_ = this.baseUrl + "/api/Notification/get-all-notification?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNotification(<any>response_);
                } catch (e) {
                    return <Observable<NotificationDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<NotificationDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNotification(response: HttpResponseBase): Observable<NotificationDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationDtoPageList>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    read(id: number | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/Notification/Read?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRead(<any>response_);
                } catch (e) {
                    return <Observable<Result>><any>_observableThrow(e);
                }
            } else
                return <Observable<Result>><any>_observableThrow(response_);
        }));
    }

    protected processRead(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(<any>null);
    }

    /**
     * @param command (optional) 
     * @return Success
     */
    notificationCount(command: NotificationCountCommand | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/Notification/NotificationCount?";
        if (command === null)
            throw new Error("The parameter 'command' cannot be null.");
        else if (command !== undefined)
            url_ += "command=" + encodeURIComponent("" + command) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotificationCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotificationCount(<any>response_);
                } catch (e) {
                    return <Observable<Result>><any>_observableThrow(e);
                }
            } else
                return <Observable<Result>><any>_observableThrow(response_);
        }));
    }

    protected processNotificationCount(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getAllNotificationForAdmin(page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortOrder: string | undefined, filter: string | undefined): Observable<NotificationDtoPageList> {
        let url_ = this.baseUrl + "/api/Notification/get-all-notification-for-admin?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNotificationForAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNotificationForAdmin(<any>response_);
                } catch (e) {
                    return <Observable<NotificationDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<NotificationDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNotificationForAdmin(response: HttpResponseBase): Observable<NotificationDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationDtoPageList>(<any>null);
    }
}

@Injectable()
export class OrderComplaintServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editOrderComplaint(body: EditOrderComplaintCommand | undefined): Observable<OrderComplaintDto> {
        let url_ = this.baseUrl + "/api/OrderComplaint/edit-OrderComplaint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditOrderComplaint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditOrderComplaint(<any>response_);
                } catch (e) {
                    return <Observable<OrderComplaintDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderComplaintDto>><any>_observableThrow(response_);
        }));
    }

    protected processEditOrderComplaint(response: HttpResponseBase): Observable<OrderComplaintDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderComplaintDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderComplaintDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrderComplaint(body: CreateOrderComplaintCommand | undefined): Observable<OrderComplaintDto> {
        let url_ = this.baseUrl + "/api/OrderComplaint/add-OrderComplaint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrderComplaint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrderComplaint(<any>response_);
                } catch (e) {
                    return <Observable<OrderComplaintDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderComplaintDto>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrderComplaint(response: HttpResponseBase): Observable<OrderComplaintDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderComplaintDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderComplaintDto>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getAllOrderComplaint(page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortOrder: string | undefined, filter: string | undefined): Observable<OrderComplaintDtoPageList> {
        let url_ = this.baseUrl + "/api/OrderComplaint/get-all-OrderComplaint?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrderComplaint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrderComplaint(<any>response_);
                } catch (e) {
                    return <Observable<OrderComplaintDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderComplaintDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllOrderComplaint(response: HttpResponseBase): Observable<OrderComplaintDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderComplaintDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderComplaintDtoPageList>(<any>null);
    }

    /**
     * @param command (optional) 
     * @return Success
     */
    getAllOrderComplaintByUserId(command: GetOrderComplaintByUserIdCommand | undefined): Observable<OrderComplaintDto[]> {
        let url_ = this.baseUrl + "/api/OrderComplaint/get-all-OrderComplaint-by-user-id?";
        if (command === null)
            throw new Error("The parameter 'command' cannot be null.");
        else if (command !== undefined)
            url_ += "command=" + encodeURIComponent("" + command) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrderComplaintByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrderComplaintByUserId(<any>response_);
                } catch (e) {
                    return <Observable<OrderComplaintDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderComplaintDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllOrderComplaintByUserId(response: HttpResponseBase): Observable<OrderComplaintDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderComplaintDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderComplaintDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOrderComplaintDetail(id: string | undefined): Observable<OrderComplaintDto> {
        let url_ = this.baseUrl + "/api/OrderComplaint/get-OrderComplaint-detail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderComplaintDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderComplaintDetail(<any>response_);
                } catch (e) {
                    return <Observable<OrderComplaintDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderComplaintDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrderComplaintDetail(response: HttpResponseBase): Observable<OrderComplaintDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderComplaintDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderComplaintDto>(<any>null);
    }
}

@Injectable()
export class RegionManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param filter (optional) 
     * @return Success
     */
    cities(page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortOrder: string | undefined, filter: string | undefined): Observable<CityDtoPageList> {
        let url_ = this.baseUrl + "/api/region-management/cities?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCities(<any>response_);
                } catch (e) {
                    return <Observable<CityDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<CityDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processCities(response: HttpResponseBase): Observable<CityDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CityDtoPageList>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param filter (optional) 
     * @return Success
     */
    countries(page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortOrder: string | undefined, filter: string | undefined): Observable<CountryDtoPageList> {
        let url_ = this.baseUrl + "/api/region-management/Countries?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountries(<any>response_);
                } catch (e) {
                    return <Observable<CountryDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processCountries(response: HttpResponseBase): Observable<CountryDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDtoPageList>(<any>null);
    }
}

@Injectable()
export class CitiesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param countryId (optional) 
     * @return Success
     */
    getCitiesByCountryId(countryId: string | undefined): Observable<CityDto[]> {
        let url_ = this.baseUrl + "/api/region-management/cities/Get-cities-by-country-id?";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCitiesByCountryId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCitiesByCountryId(<any>response_);
                } catch (e) {
                    return <Observable<CityDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CityDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCitiesByCountryId(response: HttpResponseBase): Observable<CityDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CityDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCity(body: AddCityCommand | undefined): Observable<CityDtoPageListPageList> {
        let url_ = this.baseUrl + "/api/region-management/cities/add-city";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCity(<any>response_);
                } catch (e) {
                    return <Observable<CityDtoPageListPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<CityDtoPageListPageList>><any>_observableThrow(response_);
        }));
    }

    protected processAddCity(response: HttpResponseBase): Observable<CityDtoPageListPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDtoPageListPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CityDtoPageListPageList>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editCity(id: string, body: EditCityCommand | undefined): Observable<CityDtoPageList> {
        let url_ = this.baseUrl + "/api/region-management/cities/edit-city/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditCity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditCity(<any>response_);
                } catch (e) {
                    return <Observable<CityDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<CityDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processEditCity(response: HttpResponseBase): Observable<CityDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CityDtoPageList>(<any>null);
    }

    /**
     * @return Success
     */
    deleteCity(id: string): Observable<CityDtoPageList> {
        let url_ = this.baseUrl + "/api/region-management/cities/delete-city/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCity(<any>response_);
                } catch (e) {
                    return <Observable<CityDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<CityDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCity(response: HttpResponseBase): Observable<CityDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CityDtoPageList>(<any>null);
    }
}

@Injectable()
export class CountriesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param query (optional) 
     * @return Success
     */
    getDdl(query: GetAllCountriesCommand | undefined): Observable<CountryDto[]> {
        let url_ = this.baseUrl + "/api/region-management/Countries/get-ddl?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDdl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDdl(<any>response_);
                } catch (e) {
                    return <Observable<CountryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDdl(response: HttpResponseBase): Observable<CountryDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCountry(body: CreateCountryCommand | undefined): Observable<CountryDtoPageList> {
        let url_ = this.baseUrl + "/api/region-management/Countries/add-Country";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCountry(<any>response_);
                } catch (e) {
                    return <Observable<CountryDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processAddCountry(response: HttpResponseBase): Observable<CountryDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDtoPageList>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editCountry(id: string, body: EditCountryCommand | undefined): Observable<CountryDtoPageList> {
        let url_ = this.baseUrl + "/api/region-management/Countries/edit-Country/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditCountry(<any>response_);
                } catch (e) {
                    return <Observable<CountryDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processEditCountry(response: HttpResponseBase): Observable<CountryDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDtoPageList>(<any>null);
    }

    /**
     * @return Success
     */
    deleteCountry(id: string): Observable<CountryDtoPageList> {
        let url_ = this.baseUrl + "/api/region-management/Countries/delete-country/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCountry(<any>response_);
                } catch (e) {
                    return <Observable<CountryDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCountry(response: HttpResponseBase): Observable<CountryDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDtoPageList>(<any>null);
    }
}

@Injectable()
export class ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param serviceTypeId (optional) 
     * @return Success
     */
    getServicesListByTypeId(serviceTypeId: string | undefined): Observable<ServiceDto[]> {
        let url_ = this.baseUrl + "/get-services-List-by-type-id?";
        if (serviceTypeId === null)
            throw new Error("The parameter 'serviceTypeId' cannot be null.");
        else if (serviceTypeId !== undefined)
            url_ += "ServiceTypeId=" + encodeURIComponent("" + serviceTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServicesListByTypeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServicesListByTypeId(<any>response_);
                } catch (e) {
                    return <Observable<ServiceDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetServicesListByTypeId(response: HttpResponseBase): Observable<ServiceDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServiceDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceDto[]>(<any>null);
    }

    /**
     * @param query (optional) 
     * @return Success
     */
    getServiceTypesList(query: GetServiceTypeListCommand | undefined): Observable<ServiceTypeDto[]> {
        let url_ = this.baseUrl + "/get-service-types-List?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServiceTypesList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServiceTypesList(<any>response_);
                } catch (e) {
                    return <Observable<ServiceTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetServiceTypesList(response: HttpResponseBase): Observable<ServiceTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServiceTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceTypeDto[]>(<any>null);
    }

    /**
     * @param query (optional) 
     * @return Success
     */
    getRequestTypesList(query: GetRequestTypeListCommand | undefined): Observable<ServiceTypeDto[]> {
        let url_ = this.baseUrl + "/get-request-types-List?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestTypesList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestTypesList(<any>response_);
                } catch (e) {
                    return <Observable<ServiceTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestTypesList(response: HttpResponseBase): Observable<ServiceTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServiceTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceTypeDto[]>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getService(page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortOrder: string | undefined, filter: string | undefined): Observable<ServiceTypeDtoPageList> {
        let url_ = this.baseUrl + "/get-service?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetService(<any>response_);
                } catch (e) {
                    return <Observable<ServiceTypeDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceTypeDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processGetService(response: HttpResponseBase): Observable<ServiceTypeDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceTypeDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceTypeDtoPageList>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param filter (optional) 
     * @return Success
     */
    services(page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortOrder: string | undefined, filter: string | undefined): Observable<ServiceTypeDtoPageList> {
        let url_ = this.baseUrl + "/Services?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processServices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processServices(<any>response_);
                } catch (e) {
                    return <Observable<ServiceTypeDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceTypeDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processServices(response: HttpResponseBase): Observable<ServiceTypeDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceTypeDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceTypeDtoPageList>(<any>null);
    }
}

@Injectable()
export class ServicesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addService(body: CreateServiceCommand | undefined): Observable<ServiceDtoPageList> {
        let url_ = this.baseUrl + "/Services/add-Service";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddService(<any>response_);
                } catch (e) {
                    return <Observable<ServiceDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processAddService(response: HttpResponseBase): Observable<ServiceDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceDtoPageList>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editService(id: string, body: EditServiceCommand | undefined): Observable<ServiceDtoPageList> {
        let url_ = this.baseUrl + "/Services/edit-Service/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditService(<any>response_);
                } catch (e) {
                    return <Observable<ServiceDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processEditService(response: HttpResponseBase): Observable<ServiceDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceDtoPageList>(<any>null);
    }

    /**
     * @return Success
     */
    deleteService(id: string): Observable<ServiceDtoPageList> {
        let url_ = this.baseUrl + "/Services/delete-Service/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteService(<any>response_);
                } catch (e) {
                    return <Observable<ServiceDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteService(response: HttpResponseBase): Observable<ServiceDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceDtoPageList>(<any>null);
    }
}

@Injectable()
export class UploadFileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    fileUpload(body: Blob | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/UploadFile/FileUpload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "multipart/form-data", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFileUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFileUpload(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processFileUpload(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    base(): Observable<string> {
        let url_ = this.baseUrl + "/api/UploadFile/Base";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBase(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processBase(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class UserManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param filter (optional) 
     * @return Success
     */
    roles(page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortOrder: string | undefined, filter: string | undefined): Observable<RoleDtoPageList> {
        let url_ = this.baseUrl + "/api/user-management/roles?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processRoles(response: HttpResponseBase): Observable<RoleDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPageList>(<any>null);
    }

    /**
     * @return Success
     */
    permissions(): Observable<RoleDtoPageList> {
        let url_ = this.baseUrl + "/api/user-management/permissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPermissions(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processPermissions(response: HttpResponseBase): Observable<RoleDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPageList>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addPermission(body: AddPermissionToRolCommand | undefined): Observable<RoleDtoPageList> {
        let url_ = this.baseUrl + "/api/user-management/add-permission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPermission(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processAddPermission(response: HttpResponseBase): Observable<RoleDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPageList>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    users(body: AddUserCommand | undefined): Observable<UserDtoPageList> {
        let url_ = this.baseUrl + "/api/user-management/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processUsers(response: HttpResponseBase): Observable<UserDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPageList>(<any>null);
    }
}

@Injectable()
export class RolesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addRole(body: AddRoleCommand | undefined): Observable<RoleDtoPageList> {
        let url_ = this.baseUrl + "/api/user-management/roles/add-role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRole(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processAddRole(response: HttpResponseBase): Observable<RoleDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPageList>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editRole(id: string, body: EditRoleCommand | undefined): Observable<RoleDtoPageList> {
        let url_ = this.baseUrl + "/api/user-management/roles/edit-role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditRole(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processEditRole(response: HttpResponseBase): Observable<RoleDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPageList>(<any>null);
    }

    /**
     * @return Success
     */
    deleteRole(id: string): Observable<RoleDtoPageList> {
        let url_ = this.baseUrl + "/api/user-management/roles/delete-role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<RoleDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPageList>(<any>null);
    }
}

@Injectable()
export class UsersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getallusers(page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortOrder: string | undefined, filter: string | undefined): Observable<UserDtoPageList> {
        let url_ = this.baseUrl + "/api/user-management/users/getallusers?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetallusers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetallusers(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processGetallusers(response: HttpResponseBase): Observable<UserDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPageList>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editUser(id: string, body: EditUserCommand | undefined): Observable<UserDtoPageList> {
        let url_ = this.baseUrl + "/api/user-management/users/edit-user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditUser(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processEditUser(response: HttpResponseBase): Observable<UserDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPageList>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setToken(body: SetTokenCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/user-management/users/SetToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetToken(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetToken(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setLang(body: SetLangCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/user-management/users/SetLang";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetLang(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetLang(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetLang(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUser(id: string): Observable<UserDtoPageList> {
        let url_ = this.baseUrl + "/api/user-management/users/delete-user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoPageList>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoPageList>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<UserDtoPageList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPageList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPageList>(<any>null);
    }

    /**
     * @return Success
     */
    get(id: string): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/user-management/users/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }
}

export class EditAdComplaintCommand {
    id?: string | undefined;
    complaintReason?: string | undefined;
    complaintReasonReplay?: string | undefined;
    isComplaintSeen?: boolean | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.complaintReason = _data["complaintReason"];
            this.complaintReasonReplay = _data["complaintReasonReplay"];
            this.isComplaintSeen = _data["isComplaintSeen"];
        }
    }

    static fromJS(data: any): EditAdComplaintCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditAdComplaintCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["complaintReason"] = this.complaintReason;
        data["complaintReasonReplay"] = this.complaintReasonReplay;
        data["isComplaintSeen"] = this.isComplaintSeen;
        return data; 
    }
}

export class AdComplaintDto {
    id?: string | undefined;
    complaintReason?: string | undefined;
    complaintReasonReplay?: string | undefined;
    isComplaintSeen?: boolean | undefined;
    adId?: string | undefined;
    clientId?: string | undefined;
    clientName?: string | undefined;
    adOwnerName?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.complaintReason = _data["complaintReason"];
            this.complaintReasonReplay = _data["complaintReasonReplay"];
            this.isComplaintSeen = _data["isComplaintSeen"];
            this.adId = _data["adId"];
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.adOwnerName = _data["adOwnerName"];
        }
    }

    static fromJS(data: any): AdComplaintDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdComplaintDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["complaintReason"] = this.complaintReason;
        data["complaintReasonReplay"] = this.complaintReasonReplay;
        data["isComplaintSeen"] = this.isComplaintSeen;
        data["adId"] = this.adId;
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["adOwnerName"] = this.adOwnerName;
        return data; 
    }
}

export class CreateAdComplaintCommand {
    complaintReason?: string | undefined;
    adId?: string | undefined;
    clientId?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.complaintReason = _data["complaintReason"];
            this.adId = _data["adId"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): CreateAdComplaintCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAdComplaintCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["complaintReason"] = this.complaintReason;
        data["adId"] = this.adId;
        data["clientId"] = this.clientId;
        return data; 
    }
}

export class PagedListMetaData {
    readonly pageCount?: number;
    readonly totalItemCount?: number;
    readonly pageNumber?: number;
    readonly pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    readonly isFirstPage?: boolean;
    readonly isLastPage?: boolean;
    readonly firstItemOnPage?: number;
    readonly lastItemOnPage?: number;

    init(_data?: any) {
        if (_data) {
            (<any>this).pageCount = _data["pageCount"];
            (<any>this).totalItemCount = _data["totalItemCount"];
            (<any>this).pageNumber = _data["pageNumber"];
            (<any>this).pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
            (<any>this).isFirstPage = _data["isFirstPage"];
            (<any>this).isLastPage = _data["isLastPage"];
            (<any>this).firstItemOnPage = _data["firstItemOnPage"];
            (<any>this).lastItemOnPage = _data["lastItemOnPage"];
        }
    }

    static fromJS(data: any): PagedListMetaData {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListMetaData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageCount"] = this.pageCount;
        data["totalItemCount"] = this.totalItemCount;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        data["isFirstPage"] = this.isFirstPage;
        data["isLastPage"] = this.isLastPage;
        data["firstItemOnPage"] = this.firstItemOnPage;
        data["lastItemOnPage"] = this.lastItemOnPage;
        return data; 
    }
}

export class AdComplaintDtoPageList {
    items?: AdComplaintDto[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AdComplaintDto.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AdComplaintDtoPageList {
        data = typeof data === 'object' ? data : {};
        let result = new AdComplaintDtoPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class ApplyForAdvertisementCommand {
    adId?: string | undefined;
    fromDate?: Date;
    toDate?: Date;
    servicesIds?: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.adId = _data["adId"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["servicesIds"])) {
                this.servicesIds = [] as any;
                for (let item of _data["servicesIds"])
                    this.servicesIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ApplyForAdvertisementCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyForAdvertisementCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adId"] = this.adId;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        if (Array.isArray(this.servicesIds)) {
            data["servicesIds"] = [];
            for (let item of this.servicesIds)
                data["servicesIds"].push(item);
        }
        return data; 
    }
}

export class CreateAdvertisementWithoutSPaceCommand {
    spaceInfoId?: string | undefined;
    images?: string[] | undefined;
    title?: string | undefined;
    description?: string | undefined;
    address?: string | undefined;
    isAuction?: boolean;
    fromDate?: Date;
    toDate?: Date;
    price?: number;
    auctionDays?: number;
    freeServiceIds?: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.spaceInfoId = _data["spaceInfoId"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(item);
            }
            this.title = _data["title"];
            this.description = _data["description"];
            this.address = _data["address"];
            this.isAuction = _data["isAuction"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.price = _data["price"];
            this.auctionDays = _data["auctionDays"];
            if (Array.isArray(_data["freeServiceIds"])) {
                this.freeServiceIds = [] as any;
                for (let item of _data["freeServiceIds"])
                    this.freeServiceIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateAdvertisementWithoutSPaceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAdvertisementWithoutSPaceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["spaceInfoId"] = this.spaceInfoId;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item);
        }
        data["title"] = this.title;
        data["description"] = this.description;
        data["address"] = this.address;
        data["isAuction"] = this.isAuction;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["price"] = this.price;
        data["auctionDays"] = this.auctionDays;
        if (Array.isArray(this.freeServiceIds)) {
            data["freeServiceIds"] = [];
            for (let item of this.freeServiceIds)
                data["freeServiceIds"].push(item);
        }
        return data; 
    }
}

export enum AdType {
    _0 = 0,
    _1 = 1,
}

export enum AuctionStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum AdCategoryEnum {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class AdvertisementDto {
    id?: string | undefined;
    adId?: string | undefined;
    vendorName?: string | undefined;
    image?: string | undefined;
    title?: string | undefined;
    adType?: AdType;
    description?: string | undefined;
    address?: string | undefined;
    isAuction?: boolean;
    rejected?: boolean;
    cityId?: string | undefined;
    cityName?: { [key: string]: string; } | undefined;
    clientId?: string | undefined;
    lat?: number;
    lng?: number;
    fromDate?: Date;
    toDate?: Date;
    price?: number;
    seriousSubscriptionAmount?: number;
    auctionStatus?: AuctionStatus;
    auctionDays?: number;
    adCategory?: AdCategoryEnum;
    isFavorite?: boolean | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.adId = _data["adId"];
            this.vendorName = _data["vendorName"];
            this.image = _data["image"];
            this.title = _data["title"];
            this.adType = _data["adType"];
            this.description = _data["description"];
            this.address = _data["address"];
            this.isAuction = _data["isAuction"];
            this.rejected = _data["rejected"];
            this.cityId = _data["cityId"];
            if (_data["cityName"]) {
                this.cityName = {} as any;
                for (let key in _data["cityName"]) {
                    if (_data["cityName"].hasOwnProperty(key))
                        this.cityName![key] = _data["cityName"][key];
                }
            }
            this.clientId = _data["clientId"];
            this.lat = _data["lat"];
            this.lng = _data["lng"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.price = _data["price"];
            this.seriousSubscriptionAmount = _data["seriousSubscriptionAmount"];
            this.auctionStatus = _data["auctionStatus"];
            this.auctionDays = _data["auctionDays"];
            this.adCategory = _data["adCategory"];
            this.isFavorite = _data["isFavorite"];
        }
    }

    static fromJS(data: any): AdvertisementDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertisementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["adId"] = this.adId;
        data["vendorName"] = this.vendorName;
        data["image"] = this.image;
        data["title"] = this.title;
        data["adType"] = this.adType;
        data["description"] = this.description;
        data["address"] = this.address;
        data["isAuction"] = this.isAuction;
        data["rejected"] = this.rejected;
        data["cityId"] = this.cityId;
        if (this.cityName) {
            data["cityName"] = {};
            for (let key in this.cityName) {
                if (this.cityName.hasOwnProperty(key))
                    data["cityName"][key] = this.cityName[key];
            }
        }
        data["clientId"] = this.clientId;
        data["lat"] = this.lat;
        data["lng"] = this.lng;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["price"] = this.price;
        data["seriousSubscriptionAmount"] = this.seriousSubscriptionAmount;
        data["auctionStatus"] = this.auctionStatus;
        data["auctionDays"] = this.auctionDays;
        data["adCategory"] = this.adCategory;
        data["isFavorite"] = this.isFavorite;
        return data; 
    }
}

export class CreateReservationByClientCommand {
    adId?: string | undefined;
    duration?: number;
    services?: string[] | undefined;
    amount?: number;

    init(_data?: any) {
        if (_data) {
            this.adId = _data["adId"];
            this.duration = _data["duration"];
            if (Array.isArray(_data["services"])) {
                this.services = [] as any;
                for (let item of _data["services"])
                    this.services!.push(item);
            }
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): CreateReservationByClientCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReservationByClientCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adId"] = this.adId;
        data["duration"] = this.duration;
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item);
        }
        data["amount"] = this.amount;
        return data; 
    }
}

export class StopAdvertisementCommand {
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StopAdvertisementCommand {
        data = typeof data === 'object' ? data : {};
        let result = new StopAdvertisementCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export class AddCommercialRecordCommand {
    images?: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(item);
            }
        }
    }

    static fromJS(data: any): AddCommercialRecordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddCommercialRecordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item);
        }
        return data; 
    }
}

export class PaidServicesDto {
    serviceTypeId?: string | undefined;
    price?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.serviceTypeId = _data["serviceTypeId"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): PaidServicesDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaidServicesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceTypeId"] = this.serviceTypeId;
        data["price"] = this.price;
        return data; 
    }
}

export class AddPaidServicesCommand {
    paidServices?: PaidServicesDto[] | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["paidServices"])) {
                this.paidServices = [] as any;
                for (let item of _data["paidServices"])
                    this.paidServices!.push(PaidServicesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddPaidServicesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddPaidServicesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.paidServices)) {
            data["paidServices"] = [];
            for (let item of this.paidServices)
                data["paidServices"].push(item.toJSON());
        }
        return data; 
    }
}

export class EditPaidServicesCommand {
    serviceId?: string | undefined;
    price?: number;

    init(_data?: any) {
        if (_data) {
            this.serviceId = _data["serviceId"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): EditPaidServicesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditPaidServicesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceId"] = this.serviceId;
        data["price"] = this.price;
        return data; 
    }
}

export class GetMyServiceCommand {

    init(_data?: any) {
    }

    static fromJS(data: any): GetMyServiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new GetMyServiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export class GetPaidServicesDto {
    id?: string | undefined;
    serviceTypeId?: string | undefined;
    price?: number;
    serviceName?: { [key: string]: string; } | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.serviceTypeId = _data["serviceTypeId"];
            this.price = _data["price"];
            if (_data["serviceName"]) {
                this.serviceName = {} as any;
                for (let key in _data["serviceName"]) {
                    if (_data["serviceName"].hasOwnProperty(key))
                        this.serviceName![key] = _data["serviceName"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetPaidServicesDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPaidServicesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["serviceTypeId"] = this.serviceTypeId;
        data["price"] = this.price;
        if (this.serviceName) {
            data["serviceName"] = {};
            for (let key in this.serviceName) {
                if (this.serviceName.hasOwnProperty(key))
                    data["serviceName"][key] = this.serviceName[key];
            }
        }
        return data; 
    }
}

export class GetAdServicesCommand {
    adIntervalId?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.adIntervalId = _data["adIntervalId"];
        }
    }

    static fromJS(data: any): GetAdServicesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new GetAdServicesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adIntervalId"] = this.adIntervalId;
        return data; 
    }
}

export class PaidServicesOfAdDto {
    serviceTypeName?: string | undefined;
    price?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.serviceTypeName = _data["serviceTypeName"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): PaidServicesOfAdDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaidServicesOfAdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceTypeName"] = this.serviceTypeName;
        data["price"] = this.price;
        return data; 
    }
}

export class EditAdvertisementCommand {
    id?: string | undefined;
    images?: string[] | undefined;
    title?: string | undefined;
    description?: string | undefined;
    address?: string | undefined;
    isAuction?: boolean;
    cityId?: string | undefined;
    lat?: number;
    lng?: number;
    fromDate?: Date;
    toDate?: Date;
    price?: number;
    auctionDays?: number;
    adCategory?: AdCategoryEnum;
    freeServiceIds?: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(item);
            }
            this.title = _data["title"];
            this.description = _data["description"];
            this.address = _data["address"];
            this.isAuction = _data["isAuction"];
            this.cityId = _data["cityId"];
            this.lat = _data["lat"];
            this.lng = _data["lng"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.price = _data["price"];
            this.auctionDays = _data["auctionDays"];
            this.adCategory = _data["adCategory"];
            if (Array.isArray(_data["freeServiceIds"])) {
                this.freeServiceIds = [] as any;
                for (let item of _data["freeServiceIds"])
                    this.freeServiceIds!.push(item);
            }
        }
    }

    static fromJS(data: any): EditAdvertisementCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditAdvertisementCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item);
        }
        data["title"] = this.title;
        data["description"] = this.description;
        data["address"] = this.address;
        data["isAuction"] = this.isAuction;
        data["cityId"] = this.cityId;
        data["lat"] = this.lat;
        data["lng"] = this.lng;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["price"] = this.price;
        data["auctionDays"] = this.auctionDays;
        data["adCategory"] = this.adCategory;
        if (Array.isArray(this.freeServiceIds)) {
            data["freeServiceIds"] = [];
            for (let item of this.freeServiceIds)
                data["freeServiceIds"].push(item);
        }
        return data; 
    }
}

export class CreateAdvertisementCommand {
    images?: string[] | undefined;
    title?: string | undefined;
    description?: string | undefined;
    address?: string | undefined;
    isAuction?: AdType;
    adCategory?: AdCategoryEnum;
    cityId?: string | undefined;
    lat?: number;
    lng?: number;
    fromDate?: Date;
    toDate?: Date;
    price?: number;
    auctionDays?: number;
    freeServiceIds?: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(item);
            }
            this.title = _data["title"];
            this.description = _data["description"];
            this.address = _data["address"];
            this.isAuction = _data["isAuction"];
            this.adCategory = _data["adCategory"];
            this.cityId = _data["cityId"];
            this.lat = _data["lat"];
            this.lng = _data["lng"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.price = _data["price"];
            this.auctionDays = _data["auctionDays"];
            if (Array.isArray(_data["freeServiceIds"])) {
                this.freeServiceIds = [] as any;
                for (let item of _data["freeServiceIds"])
                    this.freeServiceIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateAdvertisementCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAdvertisementCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item);
        }
        data["title"] = this.title;
        data["description"] = this.description;
        data["address"] = this.address;
        data["isAuction"] = this.isAuction;
        data["adCategory"] = this.adCategory;
        data["cityId"] = this.cityId;
        data["lat"] = this.lat;
        data["lng"] = this.lng;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["price"] = this.price;
        data["auctionDays"] = this.auctionDays;
        if (Array.isArray(this.freeServiceIds)) {
            data["freeServiceIds"] = [];
            for (let item of this.freeServiceIds)
                data["freeServiceIds"].push(item);
        }
        return data; 
    }
}

export class AdvertisementDtoPageList {
    items?: AdvertisementDto[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AdvertisementDto.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AdvertisementDtoPageList {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertisementDtoPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class SearchAdvertisementCommand {
    countryId?: string[] | undefined;
    cityId?: string[] | undefined;
    title?: string | undefined;
    maxPrice?: number;
    minPrice?: number;
    adCategoryies?: AdCategoryEnum[] | undefined;
    page?: number;
    pageSize?: number;
    sortBy?: string | undefined;
    sortOrder?: string | undefined;
    filter?: string | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["countryId"])) {
                this.countryId = [] as any;
                for (let item of _data["countryId"])
                    this.countryId!.push(item);
            }
            if (Array.isArray(_data["cityId"])) {
                this.cityId = [] as any;
                for (let item of _data["cityId"])
                    this.cityId!.push(item);
            }
            this.title = _data["title"];
            this.maxPrice = _data["maxPrice"];
            this.minPrice = _data["minPrice"];
            if (Array.isArray(_data["adCategoryies"])) {
                this.adCategoryies = [] as any;
                for (let item of _data["adCategoryies"])
                    this.adCategoryies!.push(item);
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.sortBy = _data["sortBy"];
            this.sortOrder = _data["sortOrder"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): SearchAdvertisementCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SearchAdvertisementCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.countryId)) {
            data["countryId"] = [];
            for (let item of this.countryId)
                data["countryId"].push(item);
        }
        if (Array.isArray(this.cityId)) {
            data["cityId"] = [];
            for (let item of this.cityId)
                data["cityId"].push(item);
        }
        data["title"] = this.title;
        data["maxPrice"] = this.maxPrice;
        data["minPrice"] = this.minPrice;
        if (Array.isArray(this.adCategoryies)) {
            data["adCategoryies"] = [];
            for (let item of this.adCategoryies)
                data["adCategoryies"].push(item);
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["sortBy"] = this.sortBy;
        data["sortOrder"] = this.sortOrder;
        data["filter"] = this.filter;
        return data; 
    }
}

export class SpaceInfoDto {
    id?: string | undefined;
    vendorName?: string | undefined;
    vendorEmail?: string | undefined;
    vendorPhone?: string | undefined;
    images?: string[] | undefined;
    title?: string | undefined;
    adType?: AdType;
    adCategory?: AdCategoryEnum;
    description?: string | undefined;
    address?: string | undefined;
    isAuction?: boolean;
    rejected?: boolean;
    cityId?: string | undefined;
    price?: number;
    cityName?: { [key: string]: string; } | undefined;
    lat?: number;
    lng?: number;
    adId?: string | undefined;
    adIntervalFromDate?: Date;
    adIntervalToDate?: Date;
    ratingValue?: number | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vendorName = _data["vendorName"];
            this.vendorEmail = _data["vendorEmail"];
            this.vendorPhone = _data["vendorPhone"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(item);
            }
            this.title = _data["title"];
            this.adType = _data["adType"];
            this.adCategory = _data["adCategory"];
            this.description = _data["description"];
            this.address = _data["address"];
            this.isAuction = _data["isAuction"];
            this.rejected = _data["rejected"];
            this.cityId = _data["cityId"];
            this.price = _data["price"];
            if (_data["cityName"]) {
                this.cityName = {} as any;
                for (let key in _data["cityName"]) {
                    if (_data["cityName"].hasOwnProperty(key))
                        this.cityName![key] = _data["cityName"][key];
                }
            }
            this.lat = _data["lat"];
            this.lng = _data["lng"];
            this.adId = _data["adId"];
            this.adIntervalFromDate = _data["adIntervalFromDate"] ? new Date(_data["adIntervalFromDate"].toString()) : <any>undefined;
            this.adIntervalToDate = _data["adIntervalToDate"] ? new Date(_data["adIntervalToDate"].toString()) : <any>undefined;
            this.ratingValue = _data["ratingValue"];
        }
    }

    static fromJS(data: any): SpaceInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SpaceInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vendorName"] = this.vendorName;
        data["vendorEmail"] = this.vendorEmail;
        data["vendorPhone"] = this.vendorPhone;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item);
        }
        data["title"] = this.title;
        data["adType"] = this.adType;
        data["adCategory"] = this.adCategory;
        data["description"] = this.description;
        data["address"] = this.address;
        data["isAuction"] = this.isAuction;
        data["rejected"] = this.rejected;
        data["cityId"] = this.cityId;
        data["price"] = this.price;
        if (this.cityName) {
            data["cityName"] = {};
            for (let key in this.cityName) {
                if (this.cityName.hasOwnProperty(key))
                    data["cityName"][key] = this.cityName[key];
            }
        }
        data["lat"] = this.lat;
        data["lng"] = this.lng;
        data["adId"] = this.adId;
        data["adIntervalFromDate"] = this.adIntervalFromDate ? this.adIntervalFromDate.toISOString() : <any>undefined;
        data["adIntervalToDate"] = this.adIntervalToDate ? this.adIntervalToDate.toISOString() : <any>undefined;
        data["ratingValue"] = this.ratingValue;
        return data; 
    }
}

export class FreeServiceDto {
    adId?: string | undefined;
    serviceTypeId?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.adId = _data["adId"];
            this.serviceTypeId = _data["serviceTypeId"];
        }
    }

    static fromJS(data: any): FreeServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new FreeServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adId"] = this.adId;
        data["serviceTypeId"] = this.serviceTypeId;
        return data; 
    }
}

export class AdsDto {
    id?: string | undefined;
    spaceId?: string | undefined;
    adType?: AdType;
    description?: string | undefined;
    address?: string | undefined;
    lng?: string | undefined;
    lat?: string | undefined;
    title?: string | undefined;
    cityId?: string | undefined;
    countryId?: string | undefined;
    intervalId?: string | undefined;
    vendorName?: string | undefined;
    price?: number;
    fromDate?: Date;
    toDate?: Date;
    images?: string[] | undefined;
    rejected?: boolean;
    isFavorite?: boolean | undefined;
    distance?: number | undefined;
    adCategory?: AdCategoryEnum;
    freeServices?: FreeServiceDto[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.spaceId = _data["spaceId"];
            this.adType = _data["adType"];
            this.description = _data["description"];
            this.address = _data["address"];
            this.lng = _data["lng"];
            this.lat = _data["lat"];
            this.title = _data["title"];
            this.cityId = _data["cityId"];
            this.countryId = _data["countryId"];
            this.intervalId = _data["intervalId"];
            this.vendorName = _data["vendorName"];
            this.price = _data["price"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(item);
            }
            this.rejected = _data["rejected"];
            this.isFavorite = _data["isFavorite"];
            this.distance = _data["distance"];
            this.adCategory = _data["adCategory"];
            if (Array.isArray(_data["freeServices"])) {
                this.freeServices = [] as any;
                for (let item of _data["freeServices"])
                    this.freeServices!.push(FreeServiceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["spaceId"] = this.spaceId;
        data["adType"] = this.adType;
        data["description"] = this.description;
        data["address"] = this.address;
        data["lng"] = this.lng;
        data["lat"] = this.lat;
        data["title"] = this.title;
        data["cityId"] = this.cityId;
        data["countryId"] = this.countryId;
        data["intervalId"] = this.intervalId;
        data["vendorName"] = this.vendorName;
        data["price"] = this.price;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item);
        }
        data["rejected"] = this.rejected;
        data["isFavorite"] = this.isFavorite;
        data["distance"] = this.distance;
        data["adCategory"] = this.adCategory;
        if (Array.isArray(this.freeServices)) {
            data["freeServices"] = [];
            for (let item of this.freeServices)
                data["freeServices"].push(item.toJSON());
        }
        return data; 
    }
}

export class GetMyAds {

    init(_data?: any) {
    }

    static fromJS(data: any): GetMyAds {
        data = typeof data === 'object' ? data : {};
        let result = new GetMyAds();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export class AddFavouriteCommand {
    adId?: string | undefined;
    clientId?: string | undefined;
    isFavorite?: boolean | undefined;

    init(_data?: any) {
        if (_data) {
            this.adId = _data["adId"];
            this.clientId = _data["clientId"];
            this.isFavorite = _data["isFavorite"];
        }
    }

    static fromJS(data: any): AddFavouriteCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddFavouriteCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adId"] = this.adId;
        data["clientId"] = this.clientId;
        data["isFavorite"] = this.isFavorite;
        return data; 
    }
}

export class AddFavouriteDto {
    id?: string | undefined;
    adId?: string | undefined;
    clientId?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.adId = _data["adId"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): AddFavouriteDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddFavouriteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["adId"] = this.adId;
        data["clientId"] = this.clientId;
        return data; 
    }
}

export class GetMyFavourite {

    init(_data?: any) {
    }

    static fromJS(data: any): GetMyFavourite {
        data = typeof data === 'object' ? data : {};
        let result = new GetMyFavourite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export class GetAdIntervalInstallments {
    adIntervalId?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.adIntervalId = _data["adIntervalId"];
        }
    }

    static fromJS(data: any): GetAdIntervalInstallments {
        data = typeof data === 'object' ? data : {};
        let result = new GetAdIntervalInstallments();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adIntervalId"] = this.adIntervalId;
        return data; 
    }
}

export class AdIntervalInstallmentDto {
    id?: string | undefined;
    amount?: number;
    isPaid?: boolean;
    dueDate?: Date;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.amount = _data["amount"];
            this.isPaid = _data["isPaid"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AdIntervalInstallmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdIntervalInstallmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["amount"] = this.amount;
        data["isPaid"] = this.isPaid;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        return data; 
    }
}

export class GetMySpaces {

    init(_data?: any) {
    }

    static fromJS(data: any): GetMySpaces {
        data = typeof data === 'object' ? data : {};
        let result = new GetMySpaces();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export class GetAdIntervals {
    adId?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.adId = _data["adId"];
        }
    }

    static fromJS(data: any): GetAdIntervals {
        data = typeof data === 'object' ? data : {};
        let result = new GetAdIntervals();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adId"] = this.adId;
        return data; 
    }
}

export class AdIntervalsDto {
    id?: string | undefined;
    adTitle?: string | undefined;
    clientName?: string | undefined;
    fromDate?: Date;
    toDate?: Date;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.adTitle = _data["adTitle"];
            this.clientName = _data["clientName"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AdIntervalsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdIntervalsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["adTitle"] = this.adTitle;
        data["clientName"] = this.clientName;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        return data; 
    }
}

export class GetMyServices {

    init(_data?: any) {
    }

    static fromJS(data: any): GetMyServices {
        data = typeof data === 'object' ? data : {};
        let result = new GetMyServices();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export class ServicesDto {
    id?: string | undefined;
    vendorName?: string | undefined;
    price?: number;
    name?: { [key: string]: string; } | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vendorName = _data["vendorName"];
            this.price = _data["price"];
            if (_data["name"]) {
                this.name = {} as any;
                for (let key in _data["name"]) {
                    if (_data["name"].hasOwnProperty(key))
                        this.name![key] = _data["name"][key];
                }
            }
        }
    }

    static fromJS(data: any): ServicesDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServicesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vendorName"] = this.vendorName;
        data["price"] = this.price;
        if (this.name) {
            data["name"] = {};
            for (let key in this.name) {
                if (this.name.hasOwnProperty(key))
                    data["name"][key] = this.name[key];
            }
        }
        return data; 
    }
}

export class AddRatingCommand {
    id?: string | undefined;
    adId?: string | undefined;
    clientId?: string | undefined;
    ratingValue?: number | undefined;
    ratingText?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.adId = _data["adId"];
            this.clientId = _data["clientId"];
            this.ratingValue = _data["ratingValue"];
            this.ratingText = _data["ratingText"];
        }
    }

    static fromJS(data: any): AddRatingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddRatingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["adId"] = this.adId;
        data["clientId"] = this.clientId;
        data["ratingValue"] = this.ratingValue;
        data["ratingText"] = this.ratingText;
        return data; 
    }
}

export class RatingDto {
    id?: string | undefined;
    adId?: string | undefined;
    clientId?: string | undefined;
    ratingValue?: number | undefined;
    ratingText?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.adId = _data["adId"];
            this.clientId = _data["clientId"];
            this.ratingValue = _data["ratingValue"];
            this.ratingText = _data["ratingText"];
        }
    }

    static fromJS(data: any): RatingDto {
        data = typeof data === 'object' ? data : {};
        let result = new RatingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["adId"] = this.adId;
        data["clientId"] = this.clientId;
        data["ratingValue"] = this.ratingValue;
        data["ratingText"] = this.ratingText;
        return data; 
    }
}

export class LoginCommand {
    username?: string | undefined;
    password?: string | undefined;
    lang?: string | undefined;
    webToken?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
            this.lang = _data["lang"];
            this.webToken = _data["webToken"];
        }
    }

    static fromJS(data: any): LoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        data["lang"] = this.lang;
        data["webToken"] = this.webToken;
        return data; 
    }
}

export class Result {
    success?: boolean;
    errors?: string[] | undefined;
    data?: any | undefined;
    message?: { [key: string]: string; } | undefined;

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.data = _data["data"];
            if (_data["message"]) {
                this.message = {} as any;
                for (let key in _data["message"]) {
                    if (_data["message"].hasOwnProperty(key))
                        this.message![key] = _data["message"][key];
                }
            }
        }
    }

    static fromJS(data: any): Result {
        data = typeof data === 'object' ? data : {};
        let result = new Result();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["data"] = this.data;
        if (this.message) {
            data["message"] = {};
            for (let key in this.message) {
                if (this.message.hasOwnProperty(key))
                    data["message"][key] = this.message[key];
            }
        }
        return data; 
    }
}

export class ChangePasswordCommand {
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
    confirmNewPassword?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
            this.confirmNewPassword = _data["confirmNewPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        data["confirmNewPassword"] = this.confirmNewPassword;
        return data; 
    }
}

export class ForgetPasswordCommand {
    username?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): ForgetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ForgetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        return data; 
    }
}

export class VerifyCodeCommand {
    code?: number;
    username?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): VerifyCodeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyCodeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["username"] = this.username;
        return data; 
    }
}

export class ResetPasswordCommand {
    password?: string | undefined;
    confirmPassword?: string | undefined;
    email?: string | undefined;
    token?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.email = _data["email"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["email"] = this.email;
        data["token"] = this.token;
        return data; 
    }
}

export class ClientRegisterCommand {
    email?: string | undefined;
    phoneNumber?: string | undefined;
    password?: string | undefined;
    fullName?: string | undefined;
    firstName?: string | undefined;
    avatar?: string | undefined;
    lastName?: string | undefined;
    lang?: string | undefined;
    webToken?: string | undefined;
    roles?: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.fullName = _data["fullName"];
            this.firstName = _data["firstName"];
            this.avatar = _data["avatar"];
            this.lastName = _data["lastName"];
            this.lang = _data["lang"];
            this.webToken = _data["webToken"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): ClientRegisterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRegisterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["fullName"] = this.fullName;
        data["firstName"] = this.firstName;
        data["avatar"] = this.avatar;
        data["lastName"] = this.lastName;
        data["lang"] = this.lang;
        data["webToken"] = this.webToken;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export class ClientDto {
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    error?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["error"] = this.error;
        return data; 
    }
}

export class ServiceProviderRegisterCommand {
    email?: string | undefined;
    phoneNumber?: string | undefined;
    password?: string | undefined;
    fullName?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): ServiceProviderRegisterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderRegisterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["fullName"] = this.fullName;
        return data; 
    }
}

export class GetUserByIdCommand {
    userId?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): GetUserByIdCommand {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserByIdCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data; 
    }
}

export class IsUserHasCommercialRecordCommand {

    init(_data?: any) {
    }

    static fromJS(data: any): IsUserHasCommercialRecordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new IsUserHasCommercialRecordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export class ContactUsDto {
    id?: string | undefined;
    name?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    title?: string | undefined;
    content?: string | undefined;
    responesAdmin?: string | undefined;
    notes?: string | undefined;
    isContact?: boolean | undefined;
    clientId?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.responesAdmin = _data["responesAdmin"];
            this.notes = _data["notes"];
            this.isContact = _data["isContact"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ContactUsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactUsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["title"] = this.title;
        data["content"] = this.content;
        data["responesAdmin"] = this.responesAdmin;
        data["notes"] = this.notes;
        data["isContact"] = this.isContact;
        data["clientId"] = this.clientId;
        return data; 
    }
}

export class ContactUsDtoPageList {
    items?: ContactUsDto[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContactUsDto.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactUsDtoPageList {
        data = typeof data === 'object' ? data : {};
        let result = new ContactUsDtoPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class AddContactUsCommand {
    name?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    title?: string | undefined;
    content?: string | undefined;
    responesAdmin?: string | undefined;
    notes?: string | undefined;
    isContact?: boolean | undefined;
    clientId?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.responesAdmin = _data["responesAdmin"];
            this.notes = _data["notes"];
            this.isContact = _data["isContact"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): AddContactUsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddContactUsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["title"] = this.title;
        data["content"] = this.content;
        data["responesAdmin"] = this.responesAdmin;
        data["notes"] = this.notes;
        data["isContact"] = this.isContact;
        data["clientId"] = this.clientId;
        return data; 
    }
}

export class ContactUsDtoPageListPageList {
    items?: ContactUsDtoPageList[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContactUsDtoPageList.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactUsDtoPageListPageList {
        data = typeof data === 'object' ? data : {};
        let result = new ContactUsDtoPageListPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class EditContactUsCommand {
    name?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    title?: string | undefined;
    content?: string | undefined;
    responesAdmin?: string | undefined;
    notes?: string | undefined;
    isContact?: boolean | undefined;
    clientId?: string | undefined;
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.responesAdmin = _data["responesAdmin"];
            this.notes = _data["notes"];
            this.isContact = _data["isContact"];
            this.clientId = _data["clientId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditContactUsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditContactUsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["title"] = this.title;
        data["content"] = this.content;
        data["responesAdmin"] = this.responesAdmin;
        data["notes"] = this.notes;
        data["isContact"] = this.isContact;
        data["clientId"] = this.clientId;
        data["id"] = this.id;
        return data; 
    }
}

export enum ValueTypeEnum {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export class EditGeneralConfigurationCommand {
    id?: number;
    valueType?: ValueTypeEnum;
    value?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.valueType = _data["valueType"];
            this.value = _data["value"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): EditGeneralConfigurationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditGeneralConfigurationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["valueType"] = this.valueType;
        data["value"] = this.value;
        data["name"] = this.name;
        data["code"] = this.code;
        return data; 
    }
}

export class GeneralConfigurationDto {
    id?: number;
    valueType?: ValueTypeEnum;
    value?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.valueType = _data["valueType"];
            this.value = _data["value"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): GeneralConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["valueType"] = this.valueType;
        data["value"] = this.value;
        data["name"] = this.name;
        data["code"] = this.code;
        return data; 
    }
}

export class CreateGeneralConfigurationCommand {
    valueType?: ValueTypeEnum;
    value?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.valueType = _data["valueType"];
            this.value = _data["value"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): CreateGeneralConfigurationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGeneralConfigurationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valueType"] = this.valueType;
        data["value"] = this.value;
        data["name"] = this.name;
        data["code"] = this.code;
        return data; 
    }
}

export class GeneralConfigurationDtoPageList {
    items?: GeneralConfigurationDto[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GeneralConfigurationDto.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GeneralConfigurationDtoPageList {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralConfigurationDtoPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class NotificationDto {
    id?: number;
    subject?: string | undefined;
    body?: string | undefined;
    read?: boolean;
    createdDate?: Date;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.read = _data["read"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["read"] = this.read;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data; 
    }
}

export class NotificationDtoPageList {
    items?: NotificationDto[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NotificationDto.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationDtoPageList {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDtoPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class NotificationCountCommand {

    init(_data?: any) {
    }

    static fromJS(data: any): NotificationCountCommand {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationCountCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export class EditOrderComplaintCommand {
    id?: string | undefined;
    complaintReason?: string | undefined;
    complaintReasonReplay?: string | undefined;
    isComplaintSeen?: boolean | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.complaintReason = _data["complaintReason"];
            this.complaintReasonReplay = _data["complaintReasonReplay"];
            this.isComplaintSeen = _data["isComplaintSeen"];
        }
    }

    static fromJS(data: any): EditOrderComplaintCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditOrderComplaintCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["complaintReason"] = this.complaintReason;
        data["complaintReasonReplay"] = this.complaintReasonReplay;
        data["isComplaintSeen"] = this.isComplaintSeen;
        return data; 
    }
}

export class OrderComplaintDto {
    id?: string | undefined;
    complaintReason?: string | undefined;
    complaintReasonReplay?: string | undefined;
    isComplaintSeen?: boolean | undefined;
    adId?: string | undefined;
    clientId?: string | undefined;
    clientName?: string | undefined;
    adOwnerName?: string | undefined;
    addtitle?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.complaintReason = _data["complaintReason"];
            this.complaintReasonReplay = _data["complaintReasonReplay"];
            this.isComplaintSeen = _data["isComplaintSeen"];
            this.adId = _data["adId"];
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.adOwnerName = _data["adOwnerName"];
            this.addtitle = _data["addtitle"];
        }
    }

    static fromJS(data: any): OrderComplaintDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderComplaintDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["complaintReason"] = this.complaintReason;
        data["complaintReasonReplay"] = this.complaintReasonReplay;
        data["isComplaintSeen"] = this.isComplaintSeen;
        data["adId"] = this.adId;
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["adOwnerName"] = this.adOwnerName;
        data["addtitle"] = this.addtitle;
        return data; 
    }
}

export enum ComplainType {
    _1 = 1,
    _2 = 2,
}

export class CreateOrderComplaintCommand {
    complaintReason?: string | undefined;
    orderId?: string | undefined;
    clientId?: string | undefined;
    complainType?: ComplainType;

    init(_data?: any) {
        if (_data) {
            this.complaintReason = _data["complaintReason"];
            this.orderId = _data["orderId"];
            this.clientId = _data["clientId"];
            this.complainType = _data["complainType"];
        }
    }

    static fromJS(data: any): CreateOrderComplaintCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderComplaintCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["complaintReason"] = this.complaintReason;
        data["orderId"] = this.orderId;
        data["clientId"] = this.clientId;
        data["complainType"] = this.complainType;
        return data; 
    }
}

export class OrderComplaintDtoPageList {
    items?: OrderComplaintDto[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderComplaintDto.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderComplaintDtoPageList {
        data = typeof data === 'object' ? data : {};
        let result = new OrderComplaintDtoPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class GetOrderComplaintByUserIdCommand {

    init(_data?: any) {
    }

    static fromJS(data: any): GetOrderComplaintByUserIdCommand {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrderComplaintByUserIdCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export class CityDto {
    name?: { [key: string]: string; } | undefined;
    countryName?: { [key: string]: string; } | undefined;
    id?: string | undefined;
    countryId?: string | undefined;

    init(_data?: any) {
        if (_data) {
            if (_data["name"]) {
                this.name = {} as any;
                for (let key in _data["name"]) {
                    if (_data["name"].hasOwnProperty(key))
                        this.name![key] = _data["name"][key];
                }
            }
            if (_data["countryName"]) {
                this.countryName = {} as any;
                for (let key in _data["countryName"]) {
                    if (_data["countryName"].hasOwnProperty(key))
                        this.countryName![key] = _data["countryName"][key];
                }
            }
            this.id = _data["id"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): CityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.name) {
            data["name"] = {};
            for (let key in this.name) {
                if (this.name.hasOwnProperty(key))
                    data["name"][key] = this.name[key];
            }
        }
        if (this.countryName) {
            data["countryName"] = {};
            for (let key in this.countryName) {
                if (this.countryName.hasOwnProperty(key))
                    data["countryName"][key] = this.countryName[key];
            }
        }
        data["id"] = this.id;
        data["countryId"] = this.countryId;
        return data; 
    }
}

export class CityDtoPageList {
    items?: CityDto[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CityDto.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CityDtoPageList {
        data = typeof data === 'object' ? data : {};
        let result = new CityDtoPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class AddCityCommand {
    countryId?: string | undefined;
    name?: { [key: string]: string; } | undefined;

    init(_data?: any) {
        if (_data) {
            this.countryId = _data["countryId"];
            if (_data["name"]) {
                this.name = {} as any;
                for (let key in _data["name"]) {
                    if (_data["name"].hasOwnProperty(key))
                        this.name![key] = _data["name"][key];
                }
            }
        }
    }

    static fromJS(data: any): AddCityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddCityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryId"] = this.countryId;
        if (this.name) {
            data["name"] = {};
            for (let key in this.name) {
                if (this.name.hasOwnProperty(key))
                    data["name"][key] = this.name[key];
            }
        }
        return data; 
    }
}

export class CityDtoPageListPageList {
    items?: CityDtoPageList[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CityDtoPageList.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CityDtoPageListPageList {
        data = typeof data === 'object' ? data : {};
        let result = new CityDtoPageListPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class EditCityCommand {
    countryId?: string | undefined;
    name?: { [key: string]: string; } | undefined;
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.countryId = _data["countryId"];
            if (_data["name"]) {
                this.name = {} as any;
                for (let key in _data["name"]) {
                    if (_data["name"].hasOwnProperty(key))
                        this.name![key] = _data["name"][key];
                }
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditCityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditCityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryId"] = this.countryId;
        if (this.name) {
            data["name"] = {};
            for (let key in this.name) {
                if (this.name.hasOwnProperty(key))
                    data["name"][key] = this.name[key];
            }
        }
        data["id"] = this.id;
        return data; 
    }
}

export class GetAllCountriesCommand {

    init(_data?: any) {
    }

    static fromJS(data: any): GetAllCountriesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllCountriesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export class CountryDto {
    name?: { [key: string]: string; } | undefined;
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            if (_data["name"]) {
                this.name = {} as any;
                for (let key in _data["name"]) {
                    if (_data["name"].hasOwnProperty(key))
                        this.name![key] = _data["name"][key];
                }
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.name) {
            data["name"] = {};
            for (let key in this.name) {
                if (this.name.hasOwnProperty(key))
                    data["name"][key] = this.name[key];
            }
        }
        data["id"] = this.id;
        return data; 
    }
}

export class CountryDtoPageList {
    items?: CountryDto[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CountryDto.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CountryDtoPageList {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDtoPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class CreateCountryCommand {
    name?: { [key: string]: string; } | undefined;

    init(_data?: any) {
        if (_data) {
            if (_data["name"]) {
                this.name = {} as any;
                for (let key in _data["name"]) {
                    if (_data["name"].hasOwnProperty(key))
                        this.name![key] = _data["name"][key];
                }
            }
        }
    }

    static fromJS(data: any): CreateCountryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCountryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.name) {
            data["name"] = {};
            for (let key in this.name) {
                if (this.name.hasOwnProperty(key))
                    data["name"][key] = this.name[key];
            }
        }
        return data; 
    }
}

export class EditCountryCommand {
    name?: { [key: string]: string; } | undefined;
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            if (_data["name"]) {
                this.name = {} as any;
                for (let key in _data["name"]) {
                    if (_data["name"].hasOwnProperty(key))
                        this.name![key] = _data["name"][key];
                }
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditCountryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditCountryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.name) {
            data["name"] = {};
            for (let key in this.name) {
                if (this.name.hasOwnProperty(key))
                    data["name"][key] = this.name[key];
            }
        }
        data["id"] = this.id;
        return data; 
    }
}

export class ServiceDto {
    userName?: string | undefined;
    price?: number;
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.price = _data["price"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["price"] = this.price;
        data["id"] = this.id;
        return data; 
    }
}

export class GetServiceTypeListCommand {

    init(_data?: any) {
    }

    static fromJS(data: any): GetServiceTypeListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new GetServiceTypeListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export class ServiceTypeDto {
    name?: { [key: string]: string; } | undefined;
    description?: { [key: string]: string; } | undefined;
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            if (_data["name"]) {
                this.name = {} as any;
                for (let key in _data["name"]) {
                    if (_data["name"].hasOwnProperty(key))
                        this.name![key] = _data["name"][key];
                }
            }
            if (_data["description"]) {
                this.description = {} as any;
                for (let key in _data["description"]) {
                    if (_data["description"].hasOwnProperty(key))
                        this.description![key] = _data["description"][key];
                }
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ServiceTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.name) {
            data["name"] = {};
            for (let key in this.name) {
                if (this.name.hasOwnProperty(key))
                    data["name"][key] = this.name[key];
            }
        }
        if (this.description) {
            data["description"] = {};
            for (let key in this.description) {
                if (this.description.hasOwnProperty(key))
                    data["description"][key] = this.description[key];
            }
        }
        data["id"] = this.id;
        return data; 
    }
}

export class GetRequestTypeListCommand {

    init(_data?: any) {
    }

    static fromJS(data: any): GetRequestTypeListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new GetRequestTypeListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export class ServiceTypeDtoPageList {
    items?: ServiceTypeDto[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ServiceTypeDto.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceTypeDtoPageList {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceTypeDtoPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class CreateServiceCommand {
    name?: { [key: string]: string; } | undefined;
    description?: { [key: string]: string; } | undefined;

    init(_data?: any) {
        if (_data) {
            if (_data["name"]) {
                this.name = {} as any;
                for (let key in _data["name"]) {
                    if (_data["name"].hasOwnProperty(key))
                        this.name![key] = _data["name"][key];
                }
            }
            if (_data["description"]) {
                this.description = {} as any;
                for (let key in _data["description"]) {
                    if (_data["description"].hasOwnProperty(key))
                        this.description![key] = _data["description"][key];
                }
            }
        }
    }

    static fromJS(data: any): CreateServiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateServiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.name) {
            data["name"] = {};
            for (let key in this.name) {
                if (this.name.hasOwnProperty(key))
                    data["name"][key] = this.name[key];
            }
        }
        if (this.description) {
            data["description"] = {};
            for (let key in this.description) {
                if (this.description.hasOwnProperty(key))
                    data["description"][key] = this.description[key];
            }
        }
        return data; 
    }
}

export class ServiceDtoPageList {
    items?: ServiceDto[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ServiceDto.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceDtoPageList {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceDtoPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class EditServiceCommand {
    name?: { [key: string]: string; } | undefined;
    description?: { [key: string]: string; } | undefined;
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            if (_data["name"]) {
                this.name = {} as any;
                for (let key in _data["name"]) {
                    if (_data["name"].hasOwnProperty(key))
                        this.name![key] = _data["name"][key];
                }
            }
            if (_data["description"]) {
                this.description = {} as any;
                for (let key in _data["description"]) {
                    if (_data["description"].hasOwnProperty(key))
                        this.description![key] = _data["description"][key];
                }
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditServiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditServiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.name) {
            data["name"] = {};
            for (let key in this.name) {
                if (this.name.hasOwnProperty(key))
                    data["name"][key] = this.name[key];
            }
        }
        if (this.description) {
            data["description"] = {};
            for (let key in this.description) {
                if (this.description.hasOwnProperty(key))
                    data["description"][key] = this.description[key];
            }
        }
        data["id"] = this.id;
        return data; 
    }
}

export class RoleDto {
    name?: string | undefined;
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }
}

export class RoleDtoPageList {
    items?: RoleDto[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleDto.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RoleDtoPageList {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class AddRoleCommand {
    name?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AddRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export class EditRoleCommand {
    name?: string | undefined;
    id?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }
}

export class AddPermissionToRolCommand {
    permission?: string | undefined;
    roleId?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.permission = _data["permission"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): AddPermissionToRolCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddPermissionToRolCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permission"] = this.permission;
        data["roleId"] = this.roleId;
        return data; 
    }
}

export class UserDto {
    id?: string | undefined;
    fullName?: string | undefined;
    username?: string | undefined;
    email?: string | undefined;
    roles?: string[] | undefined;
    phoneNumber?: string | undefined;
    avatar?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.username = _data["username"];
            this.email = _data["email"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.phoneNumber = _data["phoneNumber"];
            this.avatar = _data["avatar"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["username"] = this.username;
        data["email"] = this.email;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["phoneNumber"] = this.phoneNumber;
        data["avatar"] = this.avatar;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data; 
    }
}

export class UserDtoPageList {
    items?: UserDto[] | undefined;
    metadata?: PagedListMetaData | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDto.fromJS(item));
            }
            this.metadata = _data["metadata"] ? PagedListMetaData.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserDtoPageList {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export class AddUserCommand {
    userName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    phoneNumber?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;
    avatar?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.phoneNumber = _data["phoneNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): AddUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["password"] = this.password;
        data["phoneNumber"] = this.phoneNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["avatar"] = this.avatar;
        return data; 
    }
}

export class EditUserCommand {
    id?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    phoneNumber?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;
    avatar?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.phoneNumber = _data["phoneNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): EditUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["password"] = this.password;
        data["phoneNumber"] = this.phoneNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["avatar"] = this.avatar;
        return data; 
    }
}

export class SetTokenCommand {
    webToken?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.webToken = _data["webToken"];
        }
    }

    static fromJS(data: any): SetTokenCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SetTokenCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webToken"] = this.webToken;
        return data; 
    }
}

export class SetLangCommand {
    lang?: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.lang = _data["lang"];
        }
    }

    static fromJS(data: any): SetLangCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SetLangCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lang"] = this.lang;
        return data; 
    }
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}